<?xml version="1.0" encoding="utf-8"?>
<s:GridItemRenderer xmlns:fx="http://ns.adobe.com/mxml/2009"
					xmlns:s="library://ns.adobe.com/flex/spark"
					xmlns:mx="library://ns.adobe.com/flex/mx" clipAndEnableScrolling="true"
					xmlns:components="components.*"
				    xmlns:dm="dm.*"
					>
	
	<fx:Script>
		<![CDATA[
			import mx.collections.ArrayCollection;
			import spark.events.IndexChangeEvent;
			import dm.utils.tools;
			
			[Bindable] public var drawerprod_recipe:ArrayCollection;
			[Bindable] public var armCodes_recipe:ArrayCollection;
			[Bindable] public var armCodes_distinct:ArrayCollection;
			[Bindable] public var armCodes:ArrayCollection;
			
			override public function prepare(hasBeenRecycled:Boolean):void
			{
				//trace(owner);
				if (data)
				{
					//trace(tools.pr(data));
					trace(" ");
					trace("ArmCodeRender ====> prepare");
					trace("ROW_INDEX        ->"+rowIndex);
					trace("Compartment No   ->"+data.trsf_cmpt_no);
					trace("Drawer Prod Code ->"+data.trsf_drwr_prod_cd);
					drawerprod_recipe = new ArrayCollection();
					armCodes_recipe   = new ArrayCollection();
					armCodes_distinct = new ArrayCollection();
					armCodes          = new ArrayCollection();
					for each (var obj:Object in DM.ManualTransactions.arms)
					{
						// Drawer + Drawer Product ==> Arm
						if (obj.RAT_PROD_PRODCMPY == data.trsf_drwr_cd
						 && obj.RAT_PROD_PRODCODE == data.trsf_drwr_prod_cd)
						{
							// Only add the arms belong to this company+product.
							var found:int = 0;
							for each (var o:Object in armCodes_distinct)
							{
								if (obj.STREAM_ARMCODE == o.STREAM_ARMCODE)
								{
									found = 1;
									break;
								}
							}
							if (!found)
							{
								armCodes_distinct.addItem(obj);
							}
						}
					}
					
					// Check Drawer Prod recipe with Arms.
					// Only those Arms which have full Drawer Prod components can be listed.
					for each (var obj:Object in DM.ManualTransactions.productsrecipe)
					{
						// Prepare the drawer product's components.
						if (obj.PROD_CMPY == data.trsf_drwr_cd
						&& obj.PROD_CODE == data.trsf_drwr_prod_cd)
						{
							drawerprod_recipe.addItem(obj);
						}
					}
					// Check each arm.
					for each (var oArmDist:Object in armCodes_distinct)
					{
						var componentFoundCnt:int = 0;
						var baseprodCnt:int       = 0;
						
						// Prepare each arm's components.
						armCodes_recipe.removeAll();
						for each (var o2:Object in DM.ManualTransactions.arms)
						{
							if(oArmDist.RAT_PROD_PRODCMPY == o2.RAT_PROD_PRODCMPY
							&& oArmDist.RAT_PROD_PRODCODE == o2.RAT_PROD_PRODCODE
							&& oArmDist.STREAM_ARMCODE == o2.STREAM_ARMCODE)
							{
								armCodes_recipe.addItem(o2);
							}
						}
						
						// Compare drawer product component and arm component.
						for each (var o3:Object in armCodes_recipe)
						{
							for each (var objDP:Object in drawerprod_recipe)
							{
								if (objDP.RATIO_BASE == o3.STREAM_BASECODE)
								{
									componentFoundCnt++; // This arm has this component.
								}
							}
							if (o3.STREAM_BCLASS_CODE != 6) // Class 6 is ADDITIVE
							{
								baseprodCnt++; // The base prod count in this arm.
							}
						}
						
						if (componentFoundCnt == drawerprod_recipe.length && baseprodCnt >= 1) // At leaset 1 base prod needed to list this arm. If all components are ADDITIVE, this arm is not valid.
																							   // !! This part should be synced with getValidSingleArm() !!
						{
							// This arm has all the Drawer Product components.
							// So it can be listed in arm list.
							armCodes.addItem(oArmDist);
						}
					}
					
					if (DM.ManualTransactions.curr_trsf_ref.getItemAt(rowIndex).curr_trsf_drwr_cd != null
					&& DM.ManualTransactions.curr_trsf_ref.getItemAt(rowIndex).curr_trsf_drwr_prod_cd != null
					&& armCodes.length == 0)
					{
						listData.prompt = "No Arm Available";
						listData.setStyle("color", DM.ManualTransactions.TEXT_COLOR_RED);
					}
					else
					{
						listData.prompt = "Select Arm Code";
						listData.setStyle("color", DM.ManualTransactions.TEXT_COLOR_BLACK);
					}

					if (armCodes.length == 1)
					{
						// Only one arm available, so select it.
						listData.selectedIndex = 0;
					}
					else
					{
						var tmp:String = String(data[column.dataField]);
						var idx:int = -1;
						idx = tools.getItemIndexFromCode(tmp, armCodes, "STREAM_ARMCODE");
						listData.selectedIndex = idx;
					}
					
					validateArm();
					validateDensityTemp();
				}
			}
		
			protected function validateArm():void
			{
				if (listData.selectedIndex != -1)
				{
					// If one arm selected, set the arm value.
					data[column.dataField] = armCodes.getItemAt(listData.selectedIndex).STREAM_ARMCODE;
				}
				else
				{
					// If no arms selected, clear the arm value.
					data[column.dataField] = null;
				}
				
				trace("validateArm =====> arm code changed -------> baseprodDataArr/meterDataArr refresh");
				// Update transfer data reference (arm code changed).
				DM.ManualTransactions.setTransferDataRef(rowIndex, 3, data[column.dataField]);

				// Refresh child grid.
				DM.ManualTransactions.refreshChildGrid();
			}
			
			protected function validateDensityTemp():void
			{
				var dmMT:Object=DM.ManualTransactions;
				if (listData.selectedIndex != -1)
				{
					// If one arm selected, set the density value.
					if (!data.trsf_density) // Only set the default value when this cell is blank. To avoid overwrite user inputted vaule.
					{
						data.trsf_density = armCodes.getItemAt(listData.selectedIndex).STREAM_TANKDEN;
						
						// If drawer,drawer prod and arm are all populated automatically, need to display the proper density & temp.
						DM.ManualTransactions.getTankInfoByProdArm(
							DM.ManualTransactions.curr_trsf_ref.getItemAt(rowIndex).curr_trsf_drwr_cd,
							DM.ManualTransactions.curr_trsf_ref.getItemAt(rowIndex).curr_trsf_drwr_prod_cd,
							listData.selectedItem.STREAM_ARMCODE,
							rowIndex);
						trace("ArmCodeRender ====> validateDensityTemp");
						trace("Draw Code     ->"+DM.ManualTransactions.curr_trsf_ref.getItemAt(rowIndex).curr_trsf_drwr_cd);
						trace("Draw Prod Code->"+DM.ManualTransactions.curr_trsf_ref.getItemAt(rowIndex).curr_trsf_drwr_prod_cd);
						trace("Arm Code      ->"+listData.selectedItem.STREAM_ARMCODE);
						trace("Trsf Row Idx  ->"+rowIndex);
					}
				}
				else
				{
					// If no arms selected, clear the density value.
					data.trsf_density = null;
				}
			}
			
			protected function droplist_changeHandler(event:IndexChangeEvent):void
			{
				var dmMT:Object = DM.ManualTransactions;
				
				trace("Arm code renderer ==> droplist_changeHandler");
				trace("clicked row:" + rowIndex);
				trace("effectiveRowIndex:" + DM.ManualTransactions.effectiveRowIndex);
				
				// Check if the clicked row is current effective row. Ver3.0 added.
				if (DM.ManualTransactions.isCurrentEffectiveTransferRow(rowIndex) != true)
				{
					global.msgWarning("Processing data...\r\n" + "Sorry, you can't change this item at the moment.");
					DM.ManualTransactions.refreshTransferGrid();
					return;
				}
				
				// Set up lock.
				DM.ManualTransactions.lockRenderChange();
				
				// Set current transfer row index, which will be used in autoPopulateBaseMeter().
				// To prevent from user clicks somewhere else.
				DM.ManualTransactions.setTransferRowIndex(rowIndex);
				
				data[column.dataField] = listData.selectedItem.STREAM_ARMCODE;

				//0702 Clear all Base & Meter first.
				if (DM.ManualTransactions.transactionDataArr.getItemAt(rowIndex).baseprod.length > 0)
					DM.ManualTransactions.clearBaseProd(rowIndex);
				if (DM.ManualTransactions.transactionDataArr.getItemAt(rowIndex).meter.length > 0)
					DM.ManualTransactions.clearMeter(rowIndex);
				
				trace("after DM.ManualTransactions.clearBaseProd & clearMeter("+rowIndex+")");
				trace("transactionDataArr ==>");
				trace(tools.pr(DM.ManualTransactions.transactionDataArr, 2));
				trace("baseprodDataArr ==>");
				trace(tools.pr(DM.ManualTransactions.baseprodDataArr, 1));
				
				//
				// Clear cumulative base and meter data, as arm changed we need to refresh the cumulative base and meter data.
				//
				
				// Clear Base total.
				if (DM.ManualTransactions.baseprodTotalDataArr.length > 0)
					DM.ManualTransactions.clearBaseProdTotal();
				
				// Clear Meter total. Ver2.0
				if (DM.ManualTransactions.meterTotalDataArr.length > 0)
					DM.ManualTransactions.clearMeterTotal();
				
				// Get default density for the connected tank.
				//0704 DM.ManualTransactions.getTankInfoByArm(listData.selectedItem.STREAM_ARMCODE);
				DM.ManualTransactions.getTankInfoByProdArm(
					DM.ManualTransactions.curr_trsf_ref.getItemAt(rowIndex).curr_trsf_drwr_cd,
					DM.ManualTransactions.curr_trsf_ref.getItemAt(rowIndex).curr_trsf_drwr_prod_cd,
					listData.selectedItem.STREAM_ARMCODE);
				
				// Update transfer data reference (arm code changed).
				DM.ManualTransactions.setTransferDataRef(rowIndex, 3, listData.selectedItem.STREAM_ARMCODE);
				trace("Arm selection changed --------> baseprodDataArr/meterDataArr refresh");
				trace("ROW_INDEX        ->"+rowIndex);
				
				// Clear TEMP and OBS/STD/MASS.
				DM.ManualTransactions.prodarmChanged(rowIndex);
				
				// Ivalidate Base prod total arraycollection.(need to recalculate)
				DM.ManualTransactions.invalidateBaseprodTotalArr();
				
				// Refresh relevant grids.
				////DM.ManualTransactions.refreshTransferGrid();
				DM.ManualTransactions.refreshChildGrid();

				//var parnt:DataGrid = owner as DataGrid;
				//(parnt.dataProvider as ArrayCollection).refresh();
			}

		]]>
	</fx:Script>

	<fx:Declarations>
		<dm:DM/>
	</fx:Declarations>
	<!--labelField="BAA_CODE"  prompt="Select Arm Code" change="droplist_changeHandler(event)" selectedItem="@{armCode}"/>-->
	<s:DropDownList id="listData" top="0" left="0" bottom="0" right="0"
					dataProvider="{armCodes}"
					change="droplist_changeHandler(event)"
					labelField="BAY_ARM" prompt="Select Arm Code" useVirtualLayout="false"/>
	
</s:GridItemRenderer>
