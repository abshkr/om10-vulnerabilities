#!/usr/bin/python
import os, sys, time
from datetime import datetime
from logger import *
import signal
from optparse import OptionParser
from errors import *
from tree_parser import OmMsgParser
from converter import LenMRecToOmTreeConverter

from transform import Transform
from archiver import *

def __get_cmd_line_arguments():
	"""Get command line arguments."""
	#TODO: Replace OptionParser with argparse
	#cmd_arg_parser = argparse.ArgumentParser(description='Shell Leo Silver hostcomm outgoing process')
	#cmd_arg_parser.add_argument('-c', dest='config_file', help='read configuration from config_file', metavar='FILE')
	#cmd_arg_parser.add_argument('-d', dest='debug_file', help='write debug info to debug_file', metavar='FILE')
	#args = cmd_arg_parser.parse_args()
	#print 'cmd_args=<',args,'>'
	#return args

	cmd_arg_parser = OptionParser(description='Standard Omega hostcomm parser')
	#cmd_arg_parser.add_option('-c', dest='config_file', help='read configuration from config_file', metavar='FILE')
	cmd_arg_parser.add_option('-s', dest='schema_file', help='file that contains the schema of the message; if not specified, default (bai_obp_rtc.md2) is used.', metavar='FILE')
	cmd_arg_parser.add_option('-d', dest='data_file', help='file that contains the message', metavar='FILE')
	cmd_arg_parser.add_option('-n', dest='message_name', help='the start message name; if not specified, automatically retrieve from message.')
	cmd_arg_parser.add_option('-m', dest='content_format', help='1=human-readable,2=json')
	cmd_arg_parser.add_option('-o', dest='output_file', help='file that contains the result')
	options,args = cmd_arg_parser.parse_args()
	#print 'cmd_args=<',options,args,'>'
	return options,args

def sig_handler(signum, frame):
	__clean_up()
	msg = 'Received signal <%d>, process pomsg aborted.' % signum
	#logr.write_warning(msg)
	sys.exit(1)

def set_up_signals_handling():
	# Set up system signals handling
	signal.signal(signal.SIGTSTP, sig_handler)
	signal.signal(signal.SIGINT, sig_handler)
	signal.signal(signal.SIGHUP, sig_handler)
	signal.signal(signal.SIGTERM, sig_handler)


def __get_config():
	"""Retrieve configuration from config file, out_config.py, and return a module containing the info."""
	out_config = {}

	# Load default config file, config.py located in current directory
	try:
		import config
	except ImportError as err:
		#print 'ERROR: unable to load default config file', 'config.py'
		#sys.exit(1)
		contxt = 'Unable to load default config file %s: %s' % ('config.py', repr(err))
		raise Error(contxt)
	return config


def __makedirs_if_needed(config):

	dir = config.from_path
	if not os.path.isdir(dir):
		try:
			os.makedirs(dir)
		except OSError as exc: # Python >2.5
			raise

	dir = config.to_path
	if not os.path.isdir(dir):
		try:
			os.makedirs(dir)
		except OSError as exc: # Python >2.5
			raise

	dir = os.path.join(config.to_path, 'tmp')
	if not os.path.isdir(dir):
		try:
			os.makedirs(dir)
		except OSError as exc: # Python >2.5
			raise

	dir = config.from_archive_path
	if not os.path.isdir(dir):
		try:
			os.makedirs(dir)
		except OSError as exc: # Python >2.5
			raise

	dir = config.to_archive_path
	if not os.path.isdir(dir):
		try:
			os.makedirs(dir)
		except OSError as exc: # Python >2.5
			raise


def __get_message_name_from_message(data_file):
	# Assumption: An Omega message must begin with a message header of fixed list of fields of fixed lengths.
	# Read the "message type" field from the messaage, should be from byte 48 to 66 (zero-based).

	if data_file is None:
		contxt = 'Unable to retrieve message name from empty file'
		raise Error(contxt)	
	else:
		with open(data_file, 'rb') as dfile:
			firstbytes = dfile.read(66);
	
	msg_nm = firstbytes[48:].strip()
	if msg_nm is '' or msg_nm is None:
		contxt = 'File <%s> do not contain any valid message name' % data_file
		raise Error(contxt)	

	return msg_nm

def __check_inputs(opt):
	if opt.schema_file is None:
		print 'pomsg.py aborted, schema_file must be specified.'
		sys.exit(1)

	if opt.data_file is None:
		print 'pomsg.py aborted, data_file must be specified.'
		sys.exit(1)

	if opt.message_name is None:
		print 'pomsg.py aborted, message_name must be specified.'
		sys.exit(1)

	if opt.output_file is None:
		print 'pomsg.py aborted, output_file must be specified.'
		sys.exit(1)


if __name__ == "__main__":

	set_up_signals_handling()

	(options,args) = __get_cmd_line_arguments()
	__check_inputs(options)

	# Read configuration
	config = __get_config()
	__makedirs_if_needed(config)

	logr = Logger(config.log_disable, config.log_path, config.log_debug_level, config.log_backup_count)

	archiver = Archiver(logr)

	trsfm = Transform(config, archiver, logr)

	trsfm.apply(file, 1)
