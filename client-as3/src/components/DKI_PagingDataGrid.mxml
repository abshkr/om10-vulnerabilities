<?xml version="1.0" encoding="utf-8"?>
<s:DataGrid xmlns:fx="http://ns.adobe.com/mxml/2009"
			xmlns:s="library://ns.adobe.com/flex/spark" skinClass="skins.DKI_DataGrid_Skin"
			xmlns:mx="library://ns.adobe.com/flex/mx" width="400" height="300"
			mouseOver="grid_mouseOverHandler(event)"
			mouseOut="grid_mouseOutHandler(event)" 
			gridMouseDrag="gridMouseDragHandler(event)"
			creationComplete="creationCompleteHandler(event)">
	
	<fx:Script>
		<![CDATA[
			import dm.utils.dmNavigator;
			
			import mx.collections.ArrayCollection;
			import mx.core.DragSource;
			import mx.core.ScrollPolicy;
			import mx.events.CollectionEvent;
			import mx.events.DragEvent;
			import mx.events.FlexEvent;
			import mx.managers.DragManager;
			
			import renderers.DKI_HeaderColumn_Renderer;
			
			import spark.components.Scroller;
			import spark.components.VScrollBar;
			import spark.components.gridClasses.CellPosition;
			import spark.components.gridClasses.GridColumn;
			import spark.components.gridClasses.IGridItemRenderer;
			import spark.events.GridEvent;
			
			
			public var dropEnabled:Boolean=false;
			
			public var dropAction:Function= new Function();
			
			private var dropIndex:int = -1;
			
			//variables defined for paging
			//public var navigator:dmNavigator=new dmNavigator( 100, 10 );
			public var dataSize:int=50000;
			public var pageSize:int=100;
			public var currData:int;
			public var currPage:int;
			public var prevData:int;
			public var prevPage:int;
			
			
			public var gs:Scroller;
			public var vs:VScrollBar;
			
//			public var vsPage:int;
//			public var vsPos:int;
//			public var vsRecord:int;
//			public var vsValue:int;
			public var isKeyReleased:Boolean;		//true when key is released, to make sure that no remote call will occur until key is up
			public var isButtonReleased:Boolean;	//true when mouse left button is released, to make sure that no remote call will occur until button is up
			public var isValueChanged:Boolean;		//true when value_commit event is triggered, otherwise deal the changes in mouse events
			
			public var sortingBySingleColumn:Boolean = true;
			public var useCustomSorting:Boolean = false;
			public var mapObj:Object = new Object(); 
			public var orderCollection:ArrayCollection = new ArrayCollection( );
			
			public var filterAction:Function= new Function();
			public var retrieveAction:Function= new Function();
			
			
			protected function grid_mouseOverHandler(event:MouseEvent):void
			{
				scroller.verticalScrollBar.alpha=1.0;
				scroller.horizontalScrollBar.alpha=1.0;
				if (dropEnabled) addEventListener(DragEvent.DRAG_ENTER,gridDragEnter);
				
			}
			
			protected function gridMouseDragHandler(event:GridEvent):void
			{
				if (DragManager.isDragging)
					return;
			}
			
			protected function grid_mouseOutHandler(event:MouseEvent):void
			{
				scroller.verticalScrollBar.alpha=0.3;
				scroller.horizontalScrollBar.alpha=0.3;
			}
			
			private function rowDragOverHandler(event:DragEvent):void
			{
				showRowDropFeedback(event);
			}
			
			protected function gridDragEnter(event:DragEvent):void
			{
				if (event.dragSource.hasFormat("itemsByIndex"))
				{
					grid.addEventListener(DragEvent.DRAG_OVER, rowDragOverHandler);
					grid.addEventListener(DragEvent.DRAG_EXIT, rowDragExitHandler);
					grid.addEventListener(DragEvent.DRAG_DROP, rowDragDropHandler);
				}
				DragManager.acceptDragDrop(grid);
			}
			
			private function rowDragExitHandler(event:DragEvent):void
			{
				if (dropEnabled)
				{
					grid.removeEventListener(DragEvent.DRAG_OVER, rowDragOverHandler);
					grid.removeEventListener(DragEvent.DRAG_EXIT, rowDragExitHandler);
					grid.removeEventListener(DragEvent.DRAG_DROP, rowDragDropHandler);
				}
			}
			
			private function rowDragDropHandler(event:DragEvent):void
			{
				if (dropAction() != null) dropAction();
			}
			
			
			private function showRowDropFeedback(event:DragEvent):void
			{
				var pt:Point = new Point(event.stageX, event.stageY);
				pt = grid.globalToLocal(pt);
				var pos:CellPosition = grid.getCellAt(pt.x, pt.y);
				if(pos!=null)
				{
					var newDropIndex:int = pos.rowIndex;
					if ((pos.rowIndex > -1) && (pos.rowIndex < dataProvider.length)) 
						selectedIndex = pos.rowIndex;
				}
				else
					selectedIndex = -1;
			}
			
			private function initHeaderCondition(cln_index:int, cln_field:String):void
			{
				var currentRenderer:IGridItemRenderer;
				var dir:String="";
				var i:int;
				
				if ( this.sortingBySingleColumn == true )
				{	// sorted by single column only
					for (i=0; i < this.columns.length; i++)
					{
						currentRenderer = this.columnHeaderGroup.getHeaderRendererAt(i);
						if ( currentRenderer != null)
						{
							(currentRenderer as DKI_HeaderColumn_Renderer).setImage('');
							(currentRenderer as DKI_HeaderColumn_Renderer).setSortSequence('', '');
						}
					}
				}
				else
				{	// sorted by multiple columns
					;
				}
				
				currentRenderer = this.columnHeaderGroup.getHeaderRendererAt( cln_index );
				
				var orderObj:Object;
				for (i=0; i<this.orderCollection.length; i++)
				{
					orderObj = this.orderCollection.getItemAt( i );
					if ( orderObj.field == mapObj[cln_field] )
					{
						dir = orderObj.order;
						break;
					}
				}
				
				if ( currentRenderer != null)
				{
					(currentRenderer as DKI_HeaderColumn_Renderer).setImage(dir);
				}
				
				if ( global.sortingBySingleColumn == false )
				{	// sorted by multiple columns
					var currIndex:int = i;
					
					for (i=0; i<this.orderCollection.length; i++)
					{
						orderObj = this.orderCollection.getItemAt( i );
						if ( orderObj == null )
						{
							continue;
						}
						
						var j:int;
						for (j=0; j < this.columns.length; j++)
						{
							var cln:GridColumn = this.columns.getItemAt(j) as GridColumn;
							if ( orderObj.hasOwnProperty("field")==true &&  cln != null && orderObj.field == mapObj[ cln.dataField ] )
							{
								currentRenderer = this.columnHeaderGroup.getHeaderRendererAt(j);
								if ( currentRenderer != null)
								{
									(currentRenderer as DKI_HeaderColumn_Renderer).setSortSequence( orderObj.order, String(i+1) );
								}
							}
						}
					}
					
					currentRenderer = this.columnHeaderGroup.getHeaderRendererAt( cln_index );
					(currentRenderer as DKI_HeaderColumn_Renderer).setSortSequence( dir, String(currIndex+1));
					
				}
			}
			
			private function onGridHeaderClicked(event:GridEvent):void
			{
				trace ("......................in headerClickListener of multiple sorting");
				if(event.column.dataField!='')
				{
					var currentRenderer:IGridItemRenderer;
					var dir:String;
					var i:int;
					
					if ( sortingBySingleColumn == true )
					{	// sorted by single column only
						for (i=0; i < this.columns.length; i++)
						{
							currentRenderer = this.columnHeaderGroup.getHeaderRendererAt(i);
							if ( currentRenderer != null)
							{
								(currentRenderer as DKI_HeaderColumn_Renderer).setImage('');
								(currentRenderer as DKI_HeaderColumn_Renderer).setSortSequence('', '');
							}
						}
					}
					else
					{	// sorted by multiple columns
						;
					}
					currentRenderer = this.columnHeaderGroup.getHeaderRendererAt(event.columnIndex);
					
					var columnFound:Boolean = false;
					var orderObj:Object;
					for (i=0; i<this.orderCollection.length; i++)
					{
						orderObj = this.orderCollection.getItemAt( i );
						if ( orderObj.hasOwnProperty("field")==true &&  orderObj.field == mapObj[event.column.dataField] )
						{
							dir = orderObj.order;
							if( dir=="ASC" )
							{
								dir = "DESC";
							}
							else if ( dir == "DESC" )
							{
								dir = "";
							}
							else if ( dir == "" )
							{
								dir = "ASC";
							}
							else 
							{
								dir = "ASC";
							}
							
							if ( dir != "" )
							{
								orderObj.order = dir;	
							}
							else
							{
								this.orderCollection.removeItemAt( i );
							}
							
							columnFound = true;
							break;
						}
					}
					
					if ( columnFound == false )
					{
						if ( sortingBySingleColumn == true )
						{	// sorted by single column only
							this.orderCollection.removeAll();
						}
						else
						{	// sorted by multiple columns
							;
						}
						
						orderObj = new Object;
						orderObj.field = mapObj[event.column.dataField];
						orderObj.order = "ASC";
						dir = orderObj.order;
						
						this.orderCollection.addItem( orderObj );
					}
					
					(currentRenderer as DKI_HeaderColumn_Renderer).setImage(dir);
					
					if ( sortingBySingleColumn == false )
					{	// sorted by multiple columns
						var currIndex:int = i;
						
						for (i=0; i<this.orderCollection.length; i++)
						{
							orderObj = this.orderCollection.getItemAt( i );
							if ( orderObj == null )
							{
								continue;
							}
							
							var j:int;
							for (j=0; j < this.columns.length; j++)
							{
								var cln:GridColumn = this.columns.getItemAt(j) as GridColumn;
								if ( orderObj.hasOwnProperty("field")==true &&  cln != null && orderObj.field == mapObj[ cln.dataField ] )
								{
									currentRenderer = this.columnHeaderGroup.getHeaderRendererAt(j);
									if ( currentRenderer != null)
									{
										(currentRenderer as DKI_HeaderColumn_Renderer).setSortSequence( orderObj.order, String(i+1) );
									}
								}
							}
						}
						
						currentRenderer = this.columnHeaderGroup.getHeaderRendererAt(event.columnIndex);
						(currentRenderer as DKI_HeaderColumn_Renderer).setSortSequence(dir, String(currIndex+1));
						
					}
					
					if ( filterAction != null)
					{
						filterAction();
					}
				}
			}
			
			
			// PAGING FUNCTIONS
			private function creationCompleteHandler(event:FlexEvent):void
			{
				trace("-------------inside datagrid creationCompleteHandler", this.dataProvider.length, this.pageSize);
				
				dataSize = this.dataProvider.length;
				currPage = 0;
				currData = 0;
				prevPage = 0;
				prevData = 0;
				
				this.addEventListener(KeyboardEvent.KEY_DOWN, onKeyPressedDown);
				this.addEventListener(KeyboardEvent.KEY_UP, onKeyPressedUp);
				this.isKeyReleased = true;
				
				gs = this.scroller;
				if ( gs != null)
				{
					vs = gs.verticalScrollBar;
					
					if ( vs != null )
					{
						vs.addEventListener(Event.CHANGE, onGridChanged);
						vs.addEventListener(MouseEvent.MOUSE_DOWN, onVBarMouseDown);
						vs.addEventListener(MouseEvent.MOUSE_UP, onVBarMouseUp);
						trace("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@", vs.incrementButton.height, vs.decrementButton.height);
					}
				}
				this.isButtonReleased = true;
				
				if ( this.useCustomSorting == true )
				{
					this.sortableColumns = false;
					this.columnHeaderGroup.addEventListener(GridEvent.GRID_CLICK, onGridHeaderClicked);
					
					var cId:int = 0;
					var cln:GridColumn = this.columns.getItemAt(cId) as GridColumn;
					this.initHeaderCondition( cId, cln.dataField );
				}
				else
				{
					this.sortableColumns = true;
					this.sortingBySingleColumn = true;
				}
				
				this.dataProvider.addEventListener( CollectionEvent.COLLECTION_CHANGE, onDataProviderChanged);
				
				//this.columnHeaderGroup.addEventListener(GridSortEvent.SORT_CHANGE, onGridHeaderClicked);
				//this.addEventListener(GridSortEvent.SORT_CHANGE, onGridHeaderClicked);
				
				//this.removeEventListener(FlexEvent.CREATION_COMPLETE, creationCompleteHandler);
				
				this.setVerticalScrollPolicy();
				
				callLater(adjustVerticalScrollBar, ["creationCompleteHandler"]);
			}
			
			private function onDataProviderChanged(event:CollectionEvent)
			{
				trace("-------------inside datagrid onDataProviderChanged", this.dataProvider.length, this.pageSize);

				dataSize = this.dataProvider.length; 
				
				if ( currData >= this.dataProvider.length )
				{
					currData = this.dataProvider.length - 1;
				}
				prevData = currData;
				
				currPage = int(currData/pageSize);
				prevPage = currPage;
				
				
				trace( "@@@@@@@@@@@@$$$$$$$$$$$$$$$$$$$ onDataProviderChanged : "
					, "[sID]", this.selectedIndex
					, "[currRec]", currData
					, "[currPage]", currPage
					, "[totalPage]", int((dataSize-1)/pageSize + 1)
					, "[totalRecord]", dataSize
				);
				
				this.setVerticalScrollPolicy();
				
				callLater(adjustVerticalScrollBar, ["adjustGridList"]);
			}
			
			
			public function adjustGridList(current_record:int, request:Boolean):void
			{
				trace( "99999999---inside adjustGridList");
				
//				prevData = currData;
//				prevPage = currPage;
				
				if ( current_record < dataSize )
				{
					currData = current_record;
				}
				else
				{
					currData = dataSize - 1;
				}
				currPage = int(currData/pageSize);
				
				if ( (prevPage != currPage) && (request == true) )
				{
					trace( "99999999---inside adjustGridList --- retrieveGridList");
					//this.retrieveGridList();
					
					if ( retrieveAction != null)
					{
						callLater(retrieveAction);
						//callLater( invalidateDisplayList );
						//callLater(adjustVerticalScrollBar, ["adjustGridList"]);
					}
					prevData = currData;
					prevPage = currPage;
				}
			}
			
			
			public function adjustVerticalScrollBar(func:String):void
			{
				trace("!!!!!!!!!!!!!!!!!!-------Inside adjustVerticalScrollBar");
				
				vs.stepSize = this.rowHeight;
				vs.maximum = dataSize * vs.stepSize;
				if ( vs.maximum > vs.pageSize )
				{
					vs.maximum -= vs.pageSize;
				}
				
				vs.value = currData * vs.stepSize;
				this.selectedIndex = -1;//this.vsRecord - 1; 
			}
			
			public function setVerticalScrollPolicy():void
			{
				if ( dataSize*this.rowHeight > this.height )
				{
					this.setStyle ("verticalScrollPolicy", ScrollPolicy.ON);
				}
				else
				{
					this.setStyle ("verticalScrollPolicy", ScrollPolicy.OFF);
				}
			}
			
			private function onKeyPressedDown(event:KeyboardEvent):void
			{
				trace ( "DOWN-KKKKKKKK***************onKeyPressedDown:KEY CODE", event.keyCode );
				
				if ( this.isKeyReleased == true )
				{
					this.isKeyReleased = false;
				}
				
				if ( this.selectedIndex != -1 )
				{
					this.adjustGridList( this.selectedIndex+1, false );
				}
			}
			
			private function onKeyPressedUp(event:KeyboardEvent):void
			{
				if ( this.selectedIndex != -1 )
				{
					this.adjustGridList( this.selectedIndex+1, true );
				}
				this.isKeyReleased = true;
			}
			
			private function onGridChanged(event:Event):void
			{
				
				vs.stepSize = this.rowHeight;
				vs.maximum = dataSize * vs.stepSize;
				if ( vs.maximum > vs.pageSize )
				{
					vs.maximum -= vs.pageSize;
				}
				
				if ( this.isButtonReleased == false )
				{
					isValueChanged = true;
					
					this.adjustGridList( int(vs.value/vs.stepSize+0.5), false );
					this.selectedIndex = -1;//vsRecord - 1;
				}
			}
			
			private function onValueChanged(event:FlexEvent):void
			{
				
				vs.stepSize = this.rowHeight;
				vs.maximum = dataSize * vs.stepSize;
				if ( vs.maximum > vs.pageSize )
				{
					vs.maximum -= vs.pageSize;
				}
				
				if ( this.isButtonReleased == false )
				{
					isValueChanged = true;
					
					this.adjustGridList( int(vs.value/vs.stepSize+0.5), false );
					this.selectedIndex = -1;//vsRecord - 1;
				}
				
			}
			
			
			private function onVBarMouseDown(event:MouseEvent):void
			{
				systemManager.addEventListener(MouseEvent.MOUSE_UP, onVBarMouseUp);
				
				if ( this.isButtonReleased == true )
				{
					this.isButtonReleased = false;
					this.isValueChanged = false;
				}
				
				vs.stepSize = this.rowHeight;
				vs.maximum = dataSize * vs.stepSize;
				if ( vs.maximum > vs.pageSize )
				{
					vs.maximum -= vs.pageSize;
				}
				
				//this.adjustGridList( int(vs.value/vs.stepSize+0.5), false );
				this.selectedIndex = -1;//vsRecord - 1;
				
			
			}
			
			private function onVBarMouseUp(event:MouseEvent):void
			{
				systemManager.removeEventListener(MouseEvent.MOUSE_UP, onVBarMouseUp);
				
				vs.stepSize = this.rowHeight;
				vs.maximum = dataSize * vs.stepSize;
				if ( vs.maximum > vs.pageSize )
				{
					vs.maximum -= vs.pageSize;
				}
				
				if ( vs.value == 0 && this.isValueChanged==false )
				{
					//vsRecord -= 1;
				}
				this.adjustGridList( int(vs.value/vs.stepSize+0.5), true );
				this.selectedIndex = -1;//vsRecord - 1;
				
				this.isButtonReleased = true;
				
			}
			
			
		]]>
	</fx:Script>
	
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
</s:DataGrid>